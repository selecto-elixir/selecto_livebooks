# Selecto Guide - Interactive Examples

```elixir
Mix.install([
  {:selecto, path: Path.expand("../../../selecto", __DIR__)},
  {:postgrex, "~> 0.17"},
  {:ecto_sql, "~> 3.11"},
  {:jason, "~> 1.4"},
  {:kino, "~> 0.12"}
])
```

## Introduction

This Livebook demonstrates all the examples from the **Selecto Guide**. Selecto is a powerful, composable SQL query builder for Elixir that generates parameterized queries from declarative domain configurations.

Before running these examples, make sure you have:

1. Set up the `selecto_examples` database
2. Run the migrations and seeds

```bash
cd vendor/selecto_livebooks/selecto_examples
mix setup
```

## Setup: Database Connection and Domain Configurations

Run this cell first - it sets up everything needed for the examples below.

```elixir
# Configure and start the Repo
defmodule SelectoExamples.Repo do
  use Ecto.Repo,
    otp_app: :selecto_examples,
    adapter: Ecto.Adapters.Postgres
end

# Start the repo with connection settings
{:ok, _pid} = SelectoExamples.Repo.start_link(
  database: "selecto_examples_dev",
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  pool_size: 5
)

# Product Domain
product_domain = %{
  name: "Products",
  source: %{
    source_table: "products",
    primary_key: :id,
    fields: [:id, :name, :sku, :description, :price, :cost, :stock_quantity,
             :reorder_level, :active, :featured, :tags, :metadata, :category_id, :supplier_id,
             :inserted_at, :updated_at],
    columns: %{
      id: %{type: :integer},
      name: %{type: :string, label: "Product Name"},
      sku: %{type: :string, label: "SKU"},
      description: %{type: :text},
      price: %{type: :decimal, label: "Price"},
      cost: %{type: :decimal, label: "Cost"},
      stock_quantity: %{type: :integer, label: "Stock"},
      reorder_level: %{type: :integer},
      active: %{type: :boolean, label: "Active?"},
      featured: %{type: :boolean, label: "Featured?"},
      tags: %{type: {:array, :string}},
      metadata: %{type: :jsonb, label: "Metadata"},
      category_id: %{type: :integer},
      supplier_id: %{type: :integer},
      inserted_at: %{type: :utc_datetime},
      updated_at: %{type: :utc_datetime}
    },
    associations: %{
      category: %{field: :category, queryable: :categories, owner_key: :category_id, related_key: :id},
      supplier: %{field: :supplier, queryable: :suppliers, owner_key: :supplier_id, related_key: :id}
    }
  },
  schemas: %{
    categories: %{
      source_table: "categories",
      primary_key: :id,
      fields: [:id, :name, :description, :slug, :active],
      redact_fields: [],
      columns: %{
        id: %{type: :integer},
        name: %{type: :string},
        description: %{type: :text},
        slug: %{type: :string},
        active: %{type: :boolean}
      }
    },
    suppliers: %{
      source_table: "suppliers",
      primary_key: :id,
      fields: [:id, :company_name, :contact_name, :email, :city, :country, :active],
      redact_fields: [],
      columns: %{
        id: %{type: :integer},
        company_name: %{type: :string},
        contact_name: %{type: :string},
        email: %{type: :string},
        city: %{type: :string},
        country: %{type: :string},
        active: %{type: :boolean}
      }
    }
  },
  joins: %{
    category: %{
      name: "Category",
      type: :left,
      source: "categories",
      on: [%{left: "category_id", right: "id"}],
      fields: %{
        name: %{type: :string, label: "Category Name"},
        description: %{type: :text}
      }
    },
    supplier: %{
      name: "Supplier",
      type: :left,
      source: "suppliers",
      on: [%{left: "supplier_id", right: "id"}],
      fields: %{
        company_name: %{type: :string, label: "Supplier Name"},
        contact_name: %{type: :string}
      }
    }
  }
}

# Order Domain
order_domain = %{
  name: "Orders",
  source: %{
    source_table: "orders",
    primary_key: :id,
    fields: [:id, :order_number, :status, :subtotal, :tax, :shipping, :discount,
             :total, :shipping_city, :shipping_country, :customer_id,
             :shipped_at, :delivered_at, :inserted_at, :updated_at],
    columns: %{
      id: %{type: :integer},
      order_number: %{type: :string, label: "Order #"},
      status: %{type: :string, label: "Status"},
      subtotal: %{type: :decimal},
      tax: %{type: :decimal},
      shipping: %{type: :decimal},
      discount: %{type: :decimal},
      total: %{type: :decimal, label: "Total"},
      shipping_city: %{type: :string},
      shipping_country: %{type: :string},
      customer_id: %{type: :integer},
      shipped_at: %{type: :utc_datetime},
      delivered_at: %{type: :utc_datetime},
      inserted_at: %{type: :utc_datetime, label: "Order Date"},
      updated_at: %{type: :utc_datetime}
    },
    associations: %{
      customer: %{field: :customer, queryable: :customers, owner_key: :customer_id, related_key: :id},
      order_items: %{field: :order_items, queryable: :order_items, owner_key: :id, related_key: :order_id}
    }
  },
  schemas: %{
    customers: %{
      source_table: "customers",
      primary_key: :id,
      fields: [:id, :name, :email, :phone, :tier, :city, :country, :active],
      redact_fields: [],
      columns: %{
        id: %{type: :integer},
        name: %{type: :string},
        email: %{type: :string},
        phone: %{type: :string},
        tier: %{type: :string},
        city: %{type: :string},
        country: %{type: :string},
        active: %{type: :boolean}
      }
    },
    order_items: %{
      source_table: "order_items",
      primary_key: :id,
      fields: [:id, :quantity, :unit_price, :discount, :line_total, :order_id, :product_id],
      redact_fields: [],
      columns: %{
        id: %{type: :integer},
        quantity: %{type: :integer},
        unit_price: %{type: :decimal},
        discount: %{type: :decimal},
        line_total: %{type: :decimal},
        order_id: %{type: :integer},
        product_id: %{type: :integer}
      }
    }
  },
  joins: %{
    customer: %{
      name: "Customer",
      type: :left,
      source: "customers",
      on: [%{left: "customer_id", right: "id"}],
      fields: %{
        name: %{type: :string, label: "Customer Name"},
        email: %{type: :string},
        tier: %{type: :string, label: "Customer Tier"}
      }
    },
    order_items: %{
      name: "Order Items",
      type: :left,
      source: "order_items",
      on: [%{left: "id", right: "order_id"}],
      fields: %{
        quantity: %{type: :integer},
        unit_price: %{type: :decimal},
        line_total: %{type: :decimal}
      }
    }
  }
}

# Customer Domain
customer_domain = %{
  name: "Customers",
  source: %{
    source_table: "customers",
    primary_key: :id,
    fields: [:id, :name, :email, :phone, :tier, :company_name, :city, :country,
             :active, :verified_at, :inserted_at, :updated_at],
    columns: %{
      id: %{type: :integer},
      name: %{type: :string, label: "Customer Name"},
      email: %{type: :string},
      phone: %{type: :string},
      tier: %{type: :string, label: "Tier"},
      company_name: %{type: :string},
      city: %{type: :string},
      country: %{type: :string},
      active: %{type: :boolean},
      verified_at: %{type: :utc_datetime},
      inserted_at: %{type: :utc_datetime},
      updated_at: %{type: :utc_datetime}
    }
  },
  joins: %{}
}

# Employee Domain (for hierarchical examples)
employee_domain = %{
  name: "Employees",
  source: %{
    source_table: "employees",
    primary_key: :id,
    fields: [:id, :first_name, :last_name, :email, :title, :department,
             :hire_date, :salary, :active, :manager_id, :inserted_at, :updated_at],
    columns: %{
      id: %{type: :integer},
      first_name: %{type: :string},
      last_name: %{type: :string},
      email: %{type: :string},
      title: %{type: :string},
      department: %{type: :string},
      hire_date: %{type: :date},
      salary: %{type: :decimal},
      active: %{type: :boolean},
      manager_id: %{type: :integer},
      inserted_at: %{type: :utc_datetime},
      updated_at: %{type: :utc_datetime}
    },
    associations: %{
      manager: %{field: :manager, queryable: :employees, owner_key: :manager_id, related_key: :id}
    }
  },
  schemas: %{
    employees: %{
      source_table: "employees",
      primary_key: :id,
      fields: [:id, :first_name, :last_name, :email, :title, :department,
               :hire_date, :salary, :active, :manager_id],
      redact_fields: [],
      columns: %{
        id: %{type: :integer},
        first_name: %{type: :string},
        last_name: %{type: :string},
        email: %{type: :string},
        title: %{type: :string},
        department: %{type: :string},
        hire_date: %{type: :date},
        salary: %{type: :decimal},
        active: %{type: :boolean},
        manager_id: %{type: :integer}
      }
    }
  },
  joins: %{
    manager: %{
      name: "Manager",
      type: :left,
      source: "employees",
      on: [%{left: "manager_id", right: "id"}],
      fields: %{
        first_name: %{type: :string, label: "Manager First Name"},
        last_name: %{type: :string, label: "Manager Last Name"}
      }
    }
  }
}

# Order Items Domain (for product sales analysis)
order_items_domain = %{
  name: "OrderItems",
  source: %{
    source_table: "order_items",
    primary_key: :id,
    fields: [:id, :quantity, :unit_price, :line_total, :order_id, :product_id],
    columns: %{
      id: %{type: :integer},
      quantity: %{type: :integer},
      unit_price: %{type: :decimal},
      line_total: %{type: :decimal},
      order_id: %{type: :integer},
      product_id: %{type: :integer}
    },
    associations: %{
      product: %{field: :product, queryable: :products, owner_key: :product_id, related_key: :id}
    }
  },
  schemas: %{
    products: %{
      source_table: "products",
      primary_key: :id,
      fields: [:id, :name, :sku, :price],
      redact_fields: [],
      columns: %{
        id: %{type: :integer},
        name: %{type: :string},
        sku: %{type: :string},
        price: %{type: :decimal}
      }
    }
  },
  joins: %{
    product: %{
      name: "Product",
      type: :left,
      source: "products",
      on: [%{left: "product_id", right: "id"}],
      fields: %{
        name: %{type: :string},
        sku: %{type: :string}
      }
    }
  }
}

# Store everything in a map for easy access
config = %{
  repo: SelectoExamples.Repo,
  product_domain: product_domain,
  order_domain: order_domain,
  customer_domain: customer_domain,
  employee_domain: employee_domain,
  order_items_domain: order_items_domain
}

IO.puts("✓ Connected to database!")
IO.puts("✓ All domains configured!")
IO.puts("\nAvailable: config.repo, config.product_domain, config.order_domain, etc.")

config
```

```elixir
defmodule SelectoExamples.LivebookHelpers do
  @moduledoc false

  def execute_with_checks(query, opts \\ []) do
    label = Keyword.get(opts, :example, "Query")
    {sql, params} = Selecto.to_sql(query)

    IO.puts("\n[Checks] #{label}")
    print_check("SQL generated", String.trim(sql) != "")
    print_check("FROM clause present", valid_from_clause?(sql))
    print_check("params available", is_list(params))
    print_check("CTE appears consumed (if present)", cte_consumed?(sql))

    Selecto.execute(query)
  end

  defp valid_from_clause?(sql) do
    has_from = Regex.match?(~r/\bfrom\s+\S/m, sql)
    bad_from = Regex.match?(~r/\bfrom\s*(\n|\r\n)\s*where\b/mi, sql)
    has_from and not bad_from
  end

  defp cte_consumed?(sql) do
    case Regex.run(~r/\bWITH(?:\s+RECURSIVE)?\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+AS\b/m, sql) do
      nil ->
        true

      [_, cte_name] ->
        count = Regex.scan(~r/\b#{Regex.escape(cte_name)}\b/, sql) |> length()
        count > 1
    end
  end

  defp print_check(name, true), do: IO.puts("  [PASS] #{name}")
  defp print_check(name, false), do: IO.puts("  [FAIL] #{name}")
end
```

## Section 1: Basic Query Building

### Selecting Fields

```elixir
# Simple field selection
selecto = Selecto.configure(config.product_domain, config.repo)

result = selecto
|> Selecto.select(["name", "sku", "price", "stock_quantity"])
|> Selecto.limit(10)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, columns, _aliases}} ->
    IO.puts("Columns: #{inspect(columns)}")
    IO.puts("\nFirst 10 Products:")
    Enum.each(rows, fn row ->
      IO.puts("  #{inspect(row)}")
    end)
  {:error, error} ->
    IO.puts("Error: #{inspect(error)}")
end
```

### Select with Joins (dot notation)

```elixir
selecto = Selecto.configure(config.product_domain, config.repo)

result = selecto
|> Selecto.select(["name", "price", "category.name", "supplier.company_name"])
|> Selecto.limit(10)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, columns, _aliases}} ->
    IO.puts("Products with Category and Supplier:")
    IO.puts("Columns: #{inspect(columns)}")
    Enum.each(rows, fn row ->
      IO.puts("  #{inspect(row)}")
    end)
  {:error, error} ->
    IO.puts("Error: #{inspect(error)}")
end
```

## Section 2: Filtering Data

### Simple Equality Filter

```elixir
selecto = Selecto.configure(config.product_domain, config.repo)

result = selecto
|> Selecto.select(["name", "price", "active"])
|> Selecto.filter({"active", true})
|> Selecto.limit(10)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, columns, _}} ->
    IO.puts("Active Products Only:")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### Comparison Operators

```elixir
selecto = Selecto.configure(config.product_domain, config.repo)

result = selecto
|> Selecto.select(["name", "price", "stock_quantity"])
|> Selecto.filter({"price", {:gt, 50}})      # price > 50
|> Selecto.filter({"stock_quantity", {:gte, 100}})  # stock >= 100
|> Selecto.order_by({"price", :desc})
|> Selecto.limit(10)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, columns, _}} ->
    IO.puts("Products with price > 50 and stock >= 100:")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### Pattern Matching with LIKE/ILIKE

```elixir
selecto = Selecto.configure(config.product_domain, config.repo)

result = selecto
|> Selecto.select(["name", "sku", "price"])
|> Selecto.filter({"name", {:ilike, "%wireless%"}})  # Case-insensitive
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Products with 'wireless' in name:")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### IN Operator

```elixir
selecto = Selecto.configure(config.order_domain, config.repo)

result = selecto
|> Selecto.select(["order_number", "status", "total"])
|> Selecto.filter({"status", {:in, ["pending", "processing"]}})
|> Selecto.limit(10)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Pending and Processing Orders:")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### BETWEEN Filter

```elixir
selecto = Selecto.configure(config.product_domain, config.repo)

result = selecto
|> Selecto.select(["name", "price"])
|> Selecto.filter({"price", {:between, 25, 75}})
|> Selecto.order_by({"price", :asc})
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Products priced between $25 and $75:")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### NULL Checks

```elixir
selecto = Selecto.configure(config.order_domain, config.repo)

result = selecto
|> Selecto.select(["order_number", "status", "shipped_at"])
|> Selecto.filter({"shipped_at", :not_null})
|> Selecto.limit(10)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Orders that have been shipped:")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### OR Conditions

```elixir
selecto = Selecto.configure(config.order_domain, config.repo)

result = selecto
|> Selecto.select(["order_number", "status", "total"])
|> Selecto.filter({:or, [
  {"status", "pending"},
  {"status", "cancelled"}
]})
|> Selecto.limit(10)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Pending OR Cancelled Orders:")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

## Section 3: Sorting and Pagination

### Sorting Results

```elixir
selecto = Selecto.configure(config.product_domain, config.repo)

result = selecto
|> Selecto.select(["name", "category.name", "price"])
|> Selecto.order_by([
  {"category.name", :asc},
  {"price", :desc}
])
|> Selecto.limit(15)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, columns, _}} ->
    IO.puts("Products sorted by Category (asc), then Price (desc):")
    IO.puts("Columns: #{inspect(columns)}")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### Pagination

```elixir
# Page 2, 10 items per page
page = 2
per_page = 10

selecto = Selecto.configure(config.product_domain, config.repo)

result = selecto
|> Selecto.select(["name", "sku", "price"])
|> Selecto.order_by({"name", :asc})
|> Selecto.limit(per_page)
|> Selecto.offset((page - 1) * per_page)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Page #{page} (#{per_page} items per page):")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

## Section 4: Aggregates and Grouping

### Simple Aggregates

```elixir
selecto = Selecto.configure(config.product_domain, config.repo)

result = selecto
|> Selecto.select([
  {:count, "*"},
  {:avg, "price"},
  {:min, "price"},
  {:max, "price"},
  {:sum, "stock_quantity"}
])
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {[[count, avg, min, max, sum]], columns, _}} ->
    IO.puts("Product Statistics:")
    IO.puts("  Count: #{count}")
    IO.puts("  Average Price: $#{Decimal.round(avg || Decimal.new(0), 2)}")
    IO.puts("  Min Price: $#{min}")
    IO.puts("  Max Price: $#{max}")
    IO.puts("  Total Stock: #{sum}")
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### Group By with Aggregates

```elixir
selecto = Selecto.configure(config.product_domain, config.repo)

result = selecto
|> Selecto.select([
  "category.name",
  {:count, "*"},
  {:avg, "price"},
  {:sum, "stock_quantity"}
])
|> Selecto.group_by(["category.name"])
|> Selecto.order_by({{:count, "*"}, :desc})
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, columns, _}} ->
    IO.puts("Products by Category:")
    IO.puts("Columns: #{inspect(columns)}")
    Enum.each(rows, fn row ->
      [cat, count, avg, stock] = row
      IO.puts("  #{cat}: #{count} products, avg $#{Decimal.round(avg || Decimal.new(0), 2)}, #{stock} in stock")
    end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### Count Distinct

```elixir
selecto = Selecto.configure(config.order_domain, config.repo)

result = selecto
|> Selecto.select([
  {:count, "*"},
  {:count_distinct, "customer_id"},
  {:sum, "total"},
  {:avg, "total"}
])
|> Selecto.filter({"status", {:in, ["delivered", "shipped"]}})
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {[[orders, customers, revenue, avg_order]], _, _}} ->
    IO.puts("Sales Summary (Shipped/Delivered Orders):")
    IO.puts("  Total Orders: #{orders}")
    IO.puts("  Unique Customers: #{customers}")
    IO.puts("  Total Revenue: $#{Decimal.round(revenue || Decimal.new(0), 2)}")
    IO.puts("  Average Order Value: $#{Decimal.round(avg_order || Decimal.new(0), 2)}")
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

## Section 5: Joins and Associations

### Basic Joins (automatic via dot notation)

```elixir
selecto = Selecto.configure(config.order_domain, config.repo)

result = selecto
|> Selecto.select([
  "order_number",
  "status",
  "total",
  "customer.name",
  "customer.tier"
])
|> Selecto.filter({"status", "delivered"})
|> Selecto.order_by({"total", :desc})
|> Selecto.limit(10)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, columns, _}} ->
    IO.puts("Top 10 Delivered Orders with Customer Info:")
    IO.puts("Columns: #{inspect(columns)}")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### Orders by Customer Tier

```elixir
selecto = Selecto.configure(config.order_domain, config.repo)

result = selecto
|> Selecto.select([
  "customer.tier",
  {:count, "*"},
  {:sum, "total"},
  {:avg, "total"}
])
|> Selecto.group_by(["customer.tier"])
|> Selecto.order_by({{:sum, "total"}, :desc})
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Order Summary by Customer Tier:")
    Enum.each(rows, fn [tier, count, sum, avg] ->
      IO.puts("  #{tier || "unknown"}: #{count} orders, $#{Decimal.round(sum || Decimal.new(0), 2)} total, $#{Decimal.round(avg || Decimal.new(0), 2)} avg")
    end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

## Section 6: Employees with Manager (Self-Join)

```elixir
selecto = Selecto.configure(config.employee_domain, config.repo)

result = selecto
|> Selecto.select([
  "first_name",
  "last_name",
  "title",
  "department",
  "manager.first_name",
  "manager.last_name"
])
|> Selecto.order_by([{"department", :asc}, {"last_name", :asc}])
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, columns, _}} ->
    IO.puts("Employees with their Managers:")
    IO.puts("Columns: #{inspect(columns)}")
    Enum.each(rows, fn [first, last, title, dept, mgr_first, mgr_last] ->
      manager = if mgr_first, do: "#{mgr_first} #{mgr_last}", else: "(No Manager)"
      IO.puts("  #{first} #{last} - #{title} (#{dept}) - Reports to: #{manager}")
    end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

## Section 7: Advanced Queries

### Sales by Status

```elixir
selecto = Selecto.configure(config.order_domain, config.repo)

result = selecto
|> Selecto.select([
  "status",
  {:count, "*"},
  {:sum, "total"},
  {:avg, "total"}
])
|> Selecto.group_by(["status"])
|> Selecto.order_by({{:count, "*"}, :desc})
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Order Status Breakdown:")
    Enum.each(rows, fn [status, count, sum, avg] ->
      IO.puts("  #{status}: #{count} orders, $#{Decimal.round(sum || Decimal.new(0), 2)} total revenue")
    end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### Top Selling Products (via Order Items)

```elixir
selecto = Selecto.configure(config.order_items_domain, config.repo)

result = selecto
|> Selecto.select([
  "product.name",
  "product.sku",
  {:sum, "quantity"},
  {:sum, "line_total"}
])
|> Selecto.group_by(["product.name", "product.sku"])
|> Selecto.order_by({{:sum, "line_total"}, :desc})
|> Selecto.limit(10)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Top 10 Products by Revenue:")
    Enum.each(rows, fn [name, sku, qty, revenue] ->
      IO.puts("  #{name} (#{sku}): #{qty} units, $#{Decimal.round(revenue || Decimal.new(0), 2)} revenue")
    end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### Department Salary Summary

```elixir
selecto = Selecto.configure(config.employee_domain, config.repo)

result = selecto
|> Selecto.select([
  "department",
  {:count, "*"},
  {:sum, "salary"},
  {:avg, "salary"},
  {:min, "salary"},
  {:max, "salary"}
])
|> Selecto.filter({"active", true})
|> Selecto.group_by(["department"])
|> Selecto.order_by({{:sum, "salary"}, :desc})
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Salary Summary by Department:")
    Enum.each(rows, fn [dept, count, sum, avg, min, max] ->
      IO.puts("\n  #{dept}:")
      IO.puts("    Employees: #{count}")
      IO.puts("    Total Payroll: $#{Decimal.round(sum || Decimal.new(0), 2)}")
      IO.puts("    Average Salary: $#{Decimal.round(avg || Decimal.new(0), 2)}")
      IO.puts("    Range: $#{min} - $#{max}")
    end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### Pivot Example: Retarget Delivered Orders to Line Items

```elixir
pivot_query =
  Selecto.configure(config.order_domain, config.repo)
  |> Selecto.filter({"status", "delivered"})
  |> Selecto.pivot(:order_items, subquery_strategy: :exists)
  |> Selecto.select([
    {:field, "order_items.product_id", "product_id"},
    {:field, "order_items.quantity", "quantity"},
    {:field, "order_items.line_total", "line_total"}
  ])

{pivot_sql, pivot_params} = Selecto.to_sql(pivot_query)
IO.puts("Generated SQL for Pivot query:\n")
IO.puts(pivot_sql)
IO.puts("\nParams: #{inspect(pivot_params)}")

case SelectoExamples.LivebookHelpers.execute_with_checks(pivot_query, example: "Pivot Query") do
  {:ok, {rows, columns, _aliases}} ->
    IO.puts("\nLine Items from Delivered Orders (pivoted view):")
    IO.puts("Columns: #{inspect(columns)}")
    Enum.each(Enum.take(rows, 10), fn [product_id, quantity, line_total] ->
      IO.puts("  product_id=#{product_id}, qty=#{quantity}, line_total=$#{Decimal.round(line_total || Decimal.new(0), 2)}")
    end)

  {:error, error} ->
    IO.puts("Execution error: #{inspect(error)}")
end
```

### Subselect Example: Attach Order Items as JSON per Order

```elixir
subselect_query =
  Selecto.configure(config.order_domain, config.repo)
  |> Selecto.select(["order_number", "status", "total"])
  |> Selecto.filter({"status", {:in, ["processing", "shipped"]}})
  |> Selecto.subselect(
    ["order_items[quantity, line_total]"],
    format: :json_agg,
    alias_prefix: "items"
  )
  |> Selecto.order_by({"total", :desc})
  |> Selecto.limit(5)

{subselect_sql, subselect_params} = Selecto.to_sql(subselect_query)
IO.puts("Generated SQL for Subselect query:\n")
IO.puts(subselect_sql)
IO.puts("\nParams: #{inspect(subselect_params)}")

case SelectoExamples.LivebookHelpers.execute_with_checks(subselect_query, example: "Subselect Query") do
  {:ok, {rows, columns, _aliases}} ->
    IO.puts("\nTop processing/shipped orders with embedded line items:")
    IO.puts("Columns: #{inspect(columns)}")

    Enum.each(rows, fn [order_number, status, total, items] ->
      item_count = if is_list(items), do: length(items), else: 0
      IO.puts("  #{order_number} (#{status}) total=$#{Decimal.round(total || Decimal.new(0), 2)} | item_count=#{item_count}")

      items
      |> List.wrap()
      |> Enum.take(2)
      |> Enum.each(fn item ->
        IO.puts("    item: quantity=#{item["quantity"]}, line_total=#{item["line_total"]}")
      end)
    end)

  {:error, error} ->
    IO.puts("Execution error: #{inspect(error)}")
end
```

## Section 8: Composable Query Patterns

### Building Reusable Query Functions

```elixir
defmodule ProductQueries do
  def base_query(repo, domain) do
    selecto = Selecto.configure(domain, repo)
    selecto
  end

  def active_only(selecto) do
    selecto |> Selecto.filter({"active", true})
  end

  def in_stock(selecto) do
    selecto |> Selecto.filter({"stock_quantity", {:gt, 0}})
  end

  def price_range(selecto, min, max) do
    selecto |> Selecto.filter({"price", {:between, min, max}})
  end

  def paginated(selecto, page, per_page) do
    selecto
    |> Selecto.limit(per_page)
    |> Selecto.offset((page - 1) * per_page)
  end
end

# Use the composable functions
result = ProductQueries.base_query(config.repo, config.product_domain)
|> ProductQueries.active_only()
|> ProductQueries.in_stock()
|> ProductQueries.price_range(20, 100)
|> Selecto.select(["name", "price", "stock_quantity", "category.name"])
|> Selecto.order_by({"price", :asc})
|> ProductQueries.paginated(1, 10)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

case result do
  {:ok, {rows, _columns, _}} ->
    IO.puts("Active, In-Stock Products ($20-$100):")
    Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
  {:error, e} -> IO.puts("Error: #{inspect(e)}")
end
```

### Dynamic Search Function

```elixir
defmodule ProductSearch do
  def search(repo, domain, params \\ %{}) do
    selecto = Selecto.configure(domain, repo)

    selecto
    |> Selecto.select(["id", "name", "sku", "price", "stock_quantity", "category.name"])
    |> apply_search(params[:q])
    |> apply_category_filter(params[:category])
    |> apply_price_filter(params[:min_price], params[:max_price])
    |> apply_active_filter(params[:active])
    |> apply_sorting(params[:sort], params[:direction])
    |> Selecto.limit(params[:limit] || 25)
    |> SelectoExamples.LivebookHelpers.execute_with_checks()
  end

  defp apply_search(selecto, nil), do: selecto
  defp apply_search(selecto, ""), do: selecto
  defp apply_search(selecto, query) do
    selecto |> Selecto.filter({"name", {:ilike, "%#{query}%"}})
  end

  defp apply_category_filter(selecto, nil), do: selecto
  defp apply_category_filter(selecto, category) do
    selecto |> Selecto.filter({"category.name", {:ilike, "%#{category}%"}})
  end

  defp apply_price_filter(selecto, nil, nil), do: selecto
  defp apply_price_filter(selecto, min, nil) when not is_nil(min) do
    selecto |> Selecto.filter({"price", {:gte, min}})
  end
  defp apply_price_filter(selecto, nil, max) when not is_nil(max) do
    selecto |> Selecto.filter({"price", {:lte, max}})
  end
  defp apply_price_filter(selecto, min, max) do
    selecto |> Selecto.filter({"price", {:between, min, max}})
  end

  defp apply_active_filter(selecto, nil), do: selecto
  defp apply_active_filter(selecto, active) do
    selecto |> Selecto.filter({"active", active})
  end

  defp apply_sorting(selecto, nil, _), do: selecto |> Selecto.order_by({"name", :asc})
  defp apply_sorting(selecto, field, direction) do
    dir = if direction == "desc", do: :desc, else: :asc
    selecto |> Selecto.order_by({field, dir})
  end
end

# Example searches
IO.puts("\n--- Search: 'wireless' products ---")
{:ok, {rows, _, _}} = ProductSearch.search(config.repo, config.product_domain, %{q: "wireless"})
Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)

IO.puts("\n--- Search: Electronics under $100 ---")
{:ok, {rows, _, _}} = ProductSearch.search(config.repo, config.product_domain, %{
  category: "electronics",
  max_price: 100,
  sort: "price",
  direction: "asc"
})
Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)

IO.puts("\n--- Search: Active products $30-$60 ---")
{:ok, {rows, _, _}} = ProductSearch.search(config.repo, config.product_domain, %{
  active: true,
  min_price: 30,
  max_price: 60,
  limit: 10
})
Enum.each(rows, fn row -> IO.puts("  #{inspect(row)}") end)
```

## Section 9: Output Formats

### Transform to Maps

```elixir
selecto = Selecto.configure(config.product_domain, config.repo)

{:ok, {rows, columns, aliases}} = selecto
|> Selecto.select(["name", "sku", "price", "stock_quantity"])
|> Selecto.filter({"featured", true})
|> SelectoExamples.LivebookHelpers.execute_with_checks()

# Transform to maps
maps = Enum.map(rows, fn row ->
  Enum.zip(columns, row) |> Map.new()
end)

IO.puts("Featured Products as Maps:")
Enum.each(maps, fn map ->
  IO.puts("  #{map["name"]} (#{map["sku"]}): $#{map["price"]}, #{map["stock_quantity"]} in stock")
end)
```

### Create a Summary Table with Kino

```elixir
selecto = Selecto.configure(config.product_domain, config.repo)

{:ok, {rows, _columns, aliases}} = selecto
|> Selecto.select([
  {:field, "name", "product_name"},
  {:field, "sku", "sku"},
  {:field, "price", "price"},
  {:field, "stock_quantity", "stock_quantity"},
  {:field, "category.name", "category_name"}
])
|> Selecto.filter({"active", true})
|> Selecto.order_by({"price", :desc})
|> Selecto.limit(15)
|> SelectoExamples.LivebookHelpers.execute_with_checks()

# Transform for Kino DataTable
data = Enum.map(rows, fn row ->
  Enum.zip(aliases, row) |> Map.new()
end)

Kino.DataTable.new(data)
```

## Section 10: Sales Dashboard Example

Let's create a comprehensive sales dashboard using multiple queries:

```elixir
defmodule SalesDashboard do
  def generate(config) do
    IO.puts("=" |> String.duplicate(60))
    IO.puts("           SALES DASHBOARD")
    IO.puts("=" |> String.duplicate(60))

    # Overall stats
    IO.puts("\n## OVERALL STATISTICS")
    show_overall_stats(config)

    # Status breakdown
    IO.puts("\n## ORDER STATUS BREAKDOWN")
    show_status_breakdown(config)

    # Customer tier analysis
    IO.puts("\n## REVENUE BY CUSTOMER TIER")
    show_tier_analysis(config)

    # Top customers
    IO.puts("\n## TOP 5 CUSTOMERS BY REVENUE")
    show_top_customers(config)

    # Product category performance
    IO.puts("\n## PRODUCT CATEGORY SUMMARY")
    show_category_summary(config)

    IO.puts("\n" <> String.duplicate("=", 60))
  end

  defp show_overall_stats(config) do
    selecto = Selecto.configure(config.order_domain, config.repo)

    {:ok, {[[orders, customers, revenue, avg]], _, _}} = selecto
    |> Selecto.select([
      {:count, "*"},
      {:count_distinct, "customer_id"},
      {:sum, "total"},
      {:avg, "total"}
    ])
    |> SelectoExamples.LivebookHelpers.execute_with_checks()

    IO.puts("  Total Orders: #{orders}")
    IO.puts("  Unique Customers: #{customers}")
    IO.puts("  Total Revenue: $#{format_decimal(revenue)}")
    IO.puts("  Average Order Value: $#{format_decimal(avg)}")
  end

  defp show_status_breakdown(config) do
    selecto = Selecto.configure(config.order_domain, config.repo)

    {:ok, {rows, _, _}} = selecto
    |> Selecto.select([
      "status",
      {:count, "*"},
      {:sum, "total"}
    ])
    |> Selecto.group_by(["status"])
    |> Selecto.order_by({{:count, "*"}, :desc})
    |> SelectoExamples.LivebookHelpers.execute_with_checks()

    Enum.each(rows, fn [status, count, revenue] ->
      IO.puts("  #{String.pad_trailing(status, 12)}: #{String.pad_leading(to_string(count), 4)} orders, $#{format_decimal(revenue)}")
    end)
  end

  defp show_tier_analysis(config) do
    selecto = Selecto.configure(config.order_domain, config.repo)

    {:ok, {rows, _, _}} = selecto
    |> Selecto.select([
      "customer.tier",
      {:count, "*"},
      {:sum, "total"},
      {:avg, "total"}
    ])
    |> Selecto.group_by(["customer.tier"])
    |> Selecto.order_by({{:sum, "total"}, :desc})
    |> SelectoExamples.LivebookHelpers.execute_with_checks()

    Enum.each(rows, fn [tier, count, revenue, avg] ->
      IO.puts("  #{String.pad_trailing(tier || "unknown", 10)}: #{count} orders, $#{format_decimal(revenue)} total, $#{format_decimal(avg)} avg")
    end)
  end

  defp show_top_customers(config) do
    selecto = Selecto.configure(config.order_domain, config.repo)

    {:ok, {rows, _, _}} = selecto
    |> Selecto.select([
      "customer.name",
      "customer.tier",
      {:count, "*"},
      {:sum, "total"}
    ])
    |> Selecto.group_by(["customer.name", "customer.tier"])
    |> Selecto.order_by({{:sum, "total"}, :desc})
    |> Selecto.limit(5)
    |> SelectoExamples.LivebookHelpers.execute_with_checks()

    Enum.with_index(rows, 1) |> Enum.each(fn {[name, tier, orders, revenue], rank} ->
      IO.puts("  #{rank}. #{name} (#{tier}): #{orders} orders, $#{format_decimal(revenue)}")
    end)
  end

  defp show_category_summary(config) do
    selecto = Selecto.configure(config.product_domain, config.repo)

    {:ok, {rows, _, _}} = selecto
    |> Selecto.select([
      "category.name",
      {:count, "*"},
      {:avg, "price"},
      {:sum, "stock_quantity"}
    ])
    |> Selecto.group_by(["category.name"])
    |> Selecto.order_by({{:count, "*"}, :desc})
    |> SelectoExamples.LivebookHelpers.execute_with_checks()

    Enum.each(rows, fn [category, count, avg_price, stock] ->
      IO.puts("  #{String.pad_trailing(category || "Unknown", 20)}: #{count} products, $#{format_decimal(avg_price)} avg, #{stock} units")
    end)
  end

  defp format_decimal(nil), do: "0.00"
  defp format_decimal(d) when is_struct(d, Decimal), do: Decimal.round(d, 2) |> Decimal.to_string()
  defp format_decimal(n), do: :erlang.float_to_binary(n / 1, decimals: 2)
end

# Generate the dashboard
SalesDashboard.generate(config)
```

## Section 11: Set Operations (UNION / INTERSECT / EXCEPT)

Set operations are most useful when comparing meaningful cohorts.
In this example we compare two employee cohorts:

* Cohort A: employees who report to someone (`manager_id IS NOT NULL`)
* Cohort B: employees who manage at least one direct report

Each query projects the same columns so they are compatible for set operations.

```elixir
employees_with_manager =
  Selecto.configure(config.employee_domain, config.repo)
  |> Selecto.select(["id", "first_name", "last_name", "title"])
  |> Selecto.filter({"manager_id", :not_null})

employees_with_direct_reports =
  Selecto.configure(config.employee_domain, config.repo)
  |> Selecto.join(:direct_report,
    source: "employees",
    type: :inner,
    owner_key: :id,
    related_key: :manager_id,
    fields: %{
      id: %{type: :integer}
    }
  )
  |> Selecto.filter({"direct_report.id", :not_null})
  |> Selecto.select(["id", "first_name", "last_name", "title"])
  |> Selecto.group_by(["id", "first_name", "last_name", "title"])

set_queries = [
  {
    "UNION",
    "All employees who either have a manager or manage someone.",
    Selecto.union(employees_with_manager, employees_with_direct_reports)
  },
  {
    "UNION ALL",
    "Same as UNION but keeps duplicates (middle managers appear twice).",
    Selecto.union(employees_with_manager, employees_with_direct_reports, all: true)
  },
  {
    "INTERSECT",
    "Employees in both cohorts (middle managers: report to someone and manage others).",
    Selecto.intersect(employees_with_manager, employees_with_direct_reports)
  },
  {
    "EXCEPT (A - B)",
    "Employees who report to someone but do NOT manage others (individual contributors).",
    Selecto.except(employees_with_manager, employees_with_direct_reports)
  },
  {
    "EXCEPT (B - A)",
    "Employees who manage others but do NOT report to anyone (top-level leadership).",
    Selecto.except(employees_with_direct_reports, employees_with_manager)
  }
]

Enum.each(set_queries, fn {label, meaning, query} ->
  IO.puts("\n=== #{label} ===")
  IO.puts("Meaning: #{meaning}")

  {sql, params} = Selecto.to_sql(query)
  IO.puts(sql)
  IO.puts("Params: #{inspect(params)}")

  case SelectoExamples.LivebookHelpers.execute_with_checks(query) do
    {:ok, {rows, columns, _aliases}} ->
      IO.puts("Columns: #{inspect(columns)}")
      IO.puts("Row count: #{length(rows)}")
      Enum.each(Enum.take(rows, 10), fn row ->
        case row do
          [id, first_name, last_name, title] ->
            IO.puts("  ##{id} #{first_name} #{last_name} (#{title})")

          _ ->
            IO.puts("  #{inspect(row)}")
        end
      end)

    {:error, error} ->
      IO.puts("Execution error: #{inspect(error)}")
  end
end)
```

## Section 12: CTEs (WITH and WITH RECURSIVE)

### Non-Recursive CTE

Business question: Which managers have the largest direct teams, and what is each team's total salary?

Equivalent plain SQL (for intuition):

```sql
WITH manager_team_metrics AS (
  SELECT manager_id, COUNT(*) AS direct_report_count, SUM(salary) AS team_salary_total
  FROM employees
  WHERE manager_id IS NOT NULL
  GROUP BY manager_id
)
SELECT e.first_name, e.last_name, e.title,
       m.direct_report_count, m.team_salary_total
FROM employees e
JOIN manager_team_metrics m ON m.manager_id = e.id
WHERE m.direct_report_count >= 2
ORDER BY m.direct_report_count DESC
LIMIT 10;
```

```elixir
cte_query =
  Selecto.configure(config.employee_domain, config.repo)
  |> Selecto.with_cte("manager_team_metrics", fn ->
    Selecto.configure(config.employee_domain, config.repo)
    |> Selecto.select([
      "manager_id",
      {:count, "*"},
      {:sum, "salary"}
    ])
    |> Selecto.filter({"manager_id", :not_null})
    |> Selecto.group_by(["manager_id"])
  end, columns: ["manager_id", "direct_report_count", "team_salary_total"])
  |> Selecto.join(:manager_team_metrics,
    source: "manager_team_metrics",
    type: :inner,
    owner_key: :id,
    related_key: :manager_id,
    fields: %{
      manager_id: %{type: :integer},
      direct_report_count: %{type: :integer},
      team_salary_total: %{type: :decimal}
    }
  )
  |> Selecto.select([
    "first_name",
    "last_name",
    "title",
    "manager_team_metrics.direct_report_count",
    "manager_team_metrics.team_salary_total"
  ])
  |> Selecto.filter({"manager_team_metrics.direct_report_count", {:>=, 2}})
  |> Selecto.order_by({"manager_team_metrics.direct_report_count", :desc})
  |> Selecto.limit(10)

{cte_sql, cte_params} = Selecto.to_sql(cte_query)
IO.puts("Generated SQL with WITH clause:\n")
IO.puts(cte_sql)
IO.puts("\nParams: #{inspect(cte_params)}")

case SelectoExamples.LivebookHelpers.execute_with_checks(cte_query) do
  {:ok, {rows, columns, _aliases}} ->
    IO.puts("\nManager Team Metrics (from non-recursive CTE):")
    IO.puts("Columns: #{inspect(columns)}")
    Enum.each(rows, fn [mgr_first, mgr_last, title, report_count, team_salary_total] ->
      IO.puts(
        "  #{mgr_first} #{mgr_last} (#{title}) -> " <>
          "#{report_count} direct reports, total team salary $#{Decimal.round(team_salary_total || Decimal.new(0), 2)}"
      )
    end)

  {:error, error} ->
    IO.puts("Execution error: #{inspect(error)}")
end
```

Expected output checks (Non-Recursive CTE):

* SQL includes `WITH manager_team_metrics AS ( ... )`
* SQL CTE body includes `count(*)` and `sum(salary)` grouped by `manager_id`
* SQL `FROM` is not empty
* SQL references `manager_team_metrics` in the main query (not only in the CTE definition)
* Params should include the team-size threshold (for this sample: `[2]`)
* Rows should read as manager + direct report count + team salary

### Recursive CTE

Business question: Starting from the VP of Sales, show every person in that reporting tree and their depth.

Equivalent plain SQL (for intuition):

```sql
WITH RECURSIVE employee_tree_sales (id, first_name, last_name, manager_id, depth) AS (
  SELECT id, first_name, last_name, manager_id, 0
  FROM employees
  WHERE email = 'sarah.connor@company.com'
  UNION ALL
  SELECT e.id, e.first_name, e.last_name, e.manager_id, t.depth + 1
  FROM employees e
  JOIN employee_tree_sales t ON e.manager_id = t.id
)
SELECT t.depth, t.first_name, t.last_name, t.title, m.first_name, m.last_name
FROM employees e
JOIN employee_tree_sales t ON t.id = e.id
LEFT JOIN employees m ON m.id = e.manager_id
ORDER BY t.depth, t.last_name
LIMIT 15;
```

```elixir
base_query = fn ->
  Selecto.configure(config.employee_domain, config.repo)
  |> Selecto.select([
    "id",
    "first_name",
    "last_name",
    "manager_id",
    {:literal, 0}
  ])
  |> Selecto.filter({"email", "sarah.connor@company.com"})
end

recursive_query = fn _cte_ref ->
  Selecto.configure(config.employee_domain, config.repo)
  |> Selecto.join(:employee_tree_sales,
    source: "employee_tree_sales",
    type: :inner,
    owner_key: :manager_id,
    related_key: :id,
    fields: %{
      id: %{type: :integer},
      first_name: %{type: :string},
      last_name: %{type: :string},
      manager_id: %{type: :integer},
      depth: %{type: :integer}
    }
  )
  |> Selecto.select([
    "id",
    "first_name",
    "last_name",
    "manager_id",
    {:raw_sql, "employee_tree_sales.depth + 1"}
  ])
  # Required to make recursive expansion depend on prior CTE rows.
  |> Selecto.filter({"employee_tree_sales.id", :not_null})
end

recursive_cte_query =
  Selecto.configure(config.employee_domain, config.repo)
  |> Selecto.with_recursive_cte("employee_tree_sales",
    base_query: base_query,
    recursive_query: recursive_query,
    columns: ["id", "first_name", "last_name", "manager_id", "depth"]
  )
  |> Selecto.join(:employee_tree_sales,
    source: "employee_tree_sales",
    type: :inner,
    owner_key: :id,
    related_key: :id,
    fields: %{
      id: %{type: :integer},
      first_name: %{type: :string},
      last_name: %{type: :string},
      manager_id: %{type: :integer},
      depth: %{type: :integer}
    }
  )
  |> Selecto.select([
    "employee_tree_sales.depth",
    "employee_tree_sales.first_name",
    "employee_tree_sales.last_name",
    "title",
    "manager.first_name",
    "manager.last_name"
  ])
  |> Selecto.order_by({"employee_tree_sales.depth", :asc})
  |> Selecto.order_by({"employee_tree_sales.last_name", :asc})
  |> Selecto.limit(15)

{recursive_sql, recursive_params} = Selecto.to_sql(recursive_cte_query)
IO.puts("Generated SQL with WITH RECURSIVE:\n")
IO.puts(recursive_sql)
IO.puts("\nParams: #{inspect(recursive_params)}")

case SelectoExamples.LivebookHelpers.execute_with_checks(recursive_cte_query) do
  {:ok, {rows, columns, _aliases}} ->
    IO.puts("\nSales Reporting Tree (recursive CTE):")
    IO.puts("Columns: #{inspect(columns)}")
    Enum.each(rows, fn [depth, emp_first, emp_last, title, mgr_first, mgr_last] ->
      manager_name = if mgr_first, do: "#{mgr_first} #{mgr_last}", else: "(No Manager)"
      IO.puts("  depth=#{depth} | #{emp_first} #{emp_last} (#{title}) -> Manager: #{manager_name}")
    end)

  {:error, error} ->
    IO.puts("Execution error: #{inspect(error)}")
end
```

Expected output checks (Recursive CTE):

* SQL starts with `WITH RECURSIVE employee_tree_sales AS (`
* Recursive branch references the CTE via join:
  `join employee_tree_sales ... on ...manager_id = ...id`
* Main query selects from/joins `employee_tree_sales` (not just plain `from employees`)
* SQL `FROM` is not empty
* Params should include the anchor email (for this sample: `["sarah.connor@company.com"]`)
* Output should show `depth=0` for Sarah Connor, then higher depths for her reports

## Section 13: Window Functions

### Rank Employees Within Their Department

Business question: Within each department, who are the top earners and what is the department average salary next to each row?

```elixir
window_query =
  Selecto.configure(config.employee_domain, config.repo)
  |> Selecto.filter({"active", true})
  |> Selecto.select([
    "first_name",
    "last_name",
    "department",
    "salary"
  ])
  |> Selecto.window_function(:row_number, [],
    over: [partition_by: ["department"], order_by: [{"salary", :desc}]],
    as: "department_salary_rank"
  )
  |> Selecto.window_function(:avg, ["salary"],
    over: [partition_by: ["department"]],
    as: "department_avg_salary"
  )
  |> Selecto.order_by({"department", :asc})
  |> Selecto.order_by({"salary", :desc})
  |> Selecto.limit(15)

{window_sql, window_params} = Selecto.to_sql(window_query)
IO.puts("Generated SQL with window functions:\n")
IO.puts(window_sql)
IO.puts("\nParams: #{inspect(window_params)}")

case SelectoExamples.LivebookHelpers.execute_with_checks(window_query) do
  {:ok, {rows, columns, _aliases}} ->
    IO.puts("\nDepartment Salary Ranking:")
    IO.puts("Columns: #{inspect(columns)}")

    Enum.each(rows, fn [first, last, dept, salary, rank, dept_avg] ->
      IO.puts(
        "  #{dept} | ##{rank} #{first} #{last} - " <>
          "salary=$#{Decimal.round(salary || Decimal.new(0), 2)} " <>
          "(dept avg=$#{Decimal.round(dept_avg || Decimal.new(0), 2)})"
      )
    end)

  {:error, error} ->
    IO.puts("Execution error: #{inspect(error)}")
end
```

Expected output checks (Window Functions):

* SQL includes `ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ... DESC)` for ranking
* SQL includes `AVG(salary) OVER (PARTITION BY department)` for per-department average
* Rank resets to `1` for the top salary in each department

## Section 14: JSON Operations

### Filter and Project Product Metadata (JSONB)

Business question: Which active products are in the premium metadata band, and what JSON metadata values drive that classification?

```elixir
# Ensure metadata has meaningful JSON values for demonstration.
seed_result =
  config.repo.query!("""
  UPDATE products
  SET metadata = jsonb_build_object(
    'price_band',
    CASE
      WHEN price >= 100 THEN 'premium'
      WHEN price >= 50 THEN 'mid'
      ELSE 'budget'
    END,
    'warehouse',
    jsonb_build_object(
      'zone',
      CASE WHEN stock_quantity <= reorder_level THEN 'restock' ELSE 'in_stock' END,
      'bin',
      concat('A-', lpad((id % 25)::text, 2, '0'))
    ),
    'flags',
    jsonb_build_array(
      CASE WHEN active THEN 'active' ELSE 'inactive' END,
      CASE WHEN featured THEN 'featured' ELSE 'standard' END
    )
  )
  """)

IO.puts("Metadata rows refreshed for JSON example: #{seed_result.num_rows}")

json_query =
  Selecto.configure(config.product_domain, config.repo)
  |> Selecto.select(["name", "sku", "price"])
  |> Selecto.json_select([
    {:json_extract_text, "metadata", "$.price_band", as: "price_band"},
    {:json_extract_text, "metadata", "$.warehouse.zone", as: "warehouse_zone"},
    {:json_extract_text, "metadata", "$.flags[0]", as: "primary_flag"}
  ])
  |> Selecto.json_filter({:json_contains, "metadata", %{"price_band" => "premium"}})
  |> Selecto.filter({"active", true})
  |> Selecto.order_by({"price", :desc})
  |> Selecto.json_order_by({:json_extract_text, "metadata", "$.warehouse.zone", :asc})
  |> Selecto.limit(10)

{json_sql, json_params} = Selecto.to_sql(json_query)
IO.puts("Generated SQL with JSON operations:\n")
IO.puts(json_sql)
IO.puts("\nParams: #{inspect(json_params)}")

case SelectoExamples.LivebookHelpers.execute_with_checks(json_query) do
  {:ok, {rows, columns, _aliases}} ->
    IO.puts("\nPremium Products from JSON metadata:")
    IO.puts("Columns: #{inspect(columns)}")

    Enum.each(rows, fn [name, sku, price, price_band, warehouse_zone, primary_flag] ->
      IO.puts(
        "  #{name} (#{sku}) - $#{Decimal.round(price || Decimal.new(0), 2)} " <>
          "| price_band=#{price_band} | zone=#{warehouse_zone} | flag=#{primary_flag}"
      )
    end)

  {:error, error} ->
    IO.puts("Execution error: #{inspect(error)}")
end
```

Expected output checks (JSON Operations):

* SQL includes JSON extraction operators (`->` / `->>`) for metadata paths
* SQL includes JSON containment filter (`metadata @> ...`) for premium band
* Output rows show regular columns plus JSON-derived columns (`price_band`, `warehouse_zone`, `primary_flag`)

## Conclusion

This Livebook has demonstrated the core features of Selecto:

1. **Domain Configuration** - Defining your data model with sources, columns, and joins
2. **Query Building** - Using the fluent API to build queries
3. **Filtering** - Applying various filter conditions (equality, comparison, pattern matching, etc.)
4. **Sorting & Pagination** - Ordering results and implementing pagination
5. **Aggregates** - Using COUNT, SUM, AVG, MIN, MAX with GROUP BY
6. **Joins** - Automatic joins via dot notation
7. **Composable Patterns** - Building reusable query functions
8. **Output Formats** - Transforming results for different use cases
9. **Pivoting** - Retargeting query focus to related schemas while preserving filter context
10. **Subselects** - Embedding related rows as JSON arrays in each parent row
11. **Set Operations** - Combining results with UNION / INTERSECT / EXCEPT
12. **CTEs** - Using WITH and WITH RECURSIVE for modular query construction
13. **Window Functions** - Ranking and analytics across related rows without collapsing detail
14. **JSON Operations** - Extracting and filtering JSONB document data directly in SQL

For more advanced features, see:

* [Advanced Usage](../../../../selecto/guides/advanced_usage.md)
* [SQL Functions](../../../../selecto/guides/sql_functions.md)
* [Complex Join Patterns](../../../../selecto/guides/complex_join_patterns.md)
